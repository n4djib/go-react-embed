// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package models

import (
	"context"
	"time"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (name, password, created_at) VALUES (?, ?, ?)
RETURNING id, name, is_active, session, logged_at, created_at
`

type CreateUserParams struct {
	Name      string     `db:"name" json:"name" validate:"required"`
	Password  string     `db:"password" json:"password" validate:"required"`
	CreatedAt *time.Time `db:"created_at" json:"created_at"`
}

type CreateUserRow struct {
	ID        int64      `db:"id" json:"id"`
	Name      string     `db:"name" json:"name" validate:"required"`
	IsActive  *bool      `db:"is_active" json:"is_active"`
	Session   *string    `db:"session" json:"session"`
	LoggedAt  *time.Time `db:"logged_at" json:"logged_at"`
	CreatedAt *time.Time `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Name, arg.Password, arg.CreatedAt)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.Session,
		&i.LoggedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getPermissionParents = `-- name: GetPermissionParents :many
SELECT child_permission_id as permission_id, permission_id AS parent_id FROM permission_child
`

type GetPermissionParentsRow struct {
	PermissionID int64 `db:"permission_id" json:"permission_id"`
	ParentID     int64 `db:"parent_id" json:"parent_id"`
}

func (q *Queries) GetPermissionParents(ctx context.Context) ([]GetPermissionParentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPermissionParents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPermissionParentsRow
	for rows.Next() {
		var i GetPermissionParentsRow
		if err := rows.Scan(&i.PermissionID, &i.ParentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissions = `-- name: GetPermissions :many
SELECT id, permission, IFNULL(rule,"") AS rule FROM permissions
`

type GetPermissionsRow struct {
	ID         int64       `db:"id" json:"id"`
	Permission string      `db:"permission" json:"permission"`
	Rule       interface{} `db:"rule" json:"rule"`
}

func (q *Queries) GetPermissions(ctx context.Context) ([]GetPermissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPermissionsRow
	for rows.Next() {
		var i GetPermissionsRow
		if err := rows.Scan(&i.ID, &i.Permission, &i.Rule); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPokemon = `-- name: GetPokemon :one

SELECT id, name, image FROM pokemons WHERE id = ? LIMIT 1
`

// ---------------------------------------
// ---------------------------------------
func (q *Queries) GetPokemon(ctx context.Context, id int64) (Pokemon, error) {
	row := q.db.QueryRowContext(ctx, getPokemon, id)
	var i Pokemon
	err := row.Scan(&i.ID, &i.Name, &i.Image)
	return i, err
}

const getPokemonByName = `-- name: GetPokemonByName :one
SELECT id, name, image FROM pokemons WHERE name = ? LIMIT 1
`

func (q *Queries) GetPokemonByName(ctx context.Context, name string) (Pokemon, error) {
	row := q.db.QueryRowContext(ctx, getPokemonByName, name)
	var i Pokemon
	err := row.Scan(&i.ID, &i.Name, &i.Image)
	return i, err
}

const getPokemonWithPassword = `-- name: GetPokemonWithPassword :one
SELECT id, name, image FROM pokemons WHERE id = ? LIMIT 1
`

func (q *Queries) GetPokemonWithPassword(ctx context.Context, id int64) (Pokemon, error) {
	row := q.db.QueryRowContext(ctx, getPokemonWithPassword, id)
	var i Pokemon
	err := row.Scan(&i.ID, &i.Name, &i.Image)
	return i, err
}

const getRoleParents = `-- name: GetRoleParents :many


SELECT child_role_id AS role_id, role_id AS parent_id FROM role_child
`

type GetRoleParentsRow struct {
	RoleID   int64 `db:"role_id" json:"role_id"`
	ParentID int64 `db:"parent_id" json:"parent_id"`
}

// -- name: GetRoleParents :many
// SELECT r.id, r.role, rc.role_id AS parent_id FROM roles r
//
//	JOIN role_child rc ON r.id = rc.child_role_id;
//
// -- name: GetPermissionParents :many
// SELECT p.id, p.permission, pc.permission_id AS parent_id FROM permissions p
//
//	JOIN permission_child pc ON p.id = pc.child_permission_id;
func (q *Queries) GetRoleParents(ctx context.Context) ([]GetRoleParentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoleParents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoleParentsRow
	for rows.Next() {
		var i GetRoleParentsRow
		if err := rows.Scan(&i.RoleID, &i.ParentID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolePermissions = `-- name: GetRolePermissions :many
SELECT role_id, permission_id FROM role_permissions
`

func (q *Queries) GetRolePermissions(ctx context.Context) ([]RolePermission, error) {
	rows, err := q.db.QueryContext(ctx, getRolePermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RolePermission
	for rows.Next() {
		var i RolePermission
		if err := rows.Scan(&i.RoleID, &i.PermissionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoles = `-- name: GetRoles :many

SELECT id, role FROM roles
`

type GetRolesRow struct {
	ID   int64  `db:"id" json:"id"`
	Role string `db:"role" json:"role"`
}

// ---------------------------------------
// ---------------------------------------
// RBAC
func (q *Queries) GetRoles(ctx context.Context) ([]GetRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRolesRow
	for rows.Next() {
		var i GetRolesRow
		if err := rows.Scan(&i.ID, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, name, is_active, session, logged_at, created_at
  FROM users WHERE id = ? LIMIT 1
`

type GetUserRow struct {
	ID        int64      `db:"id" json:"id"`
	Name      string     `db:"name" json:"name" validate:"required"`
	IsActive  *bool      `db:"is_active" json:"is_active"`
	Session   *string    `db:"session" json:"session"`
	LoggedAt  *time.Time `db:"logged_at" json:"logged_at"`
	CreatedAt *time.Time `db:"created_at" json:"created_at"`
}

func (q *Queries) GetUser(ctx context.Context, id int64) (GetUserRow, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i GetUserRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.Session,
		&i.LoggedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByName = `-- name: GetUserByName :one
SELECT id, name, is_active, session, logged_at, created_at
  FROM users WHERE name = ? LIMIT 1
`

type GetUserByNameRow struct {
	ID        int64      `db:"id" json:"id"`
	Name      string     `db:"name" json:"name" validate:"required"`
	IsActive  *bool      `db:"is_active" json:"is_active"`
	Session   *string    `db:"session" json:"session"`
	LoggedAt  *time.Time `db:"logged_at" json:"logged_at"`
	CreatedAt *time.Time `db:"created_at" json:"created_at"`
}

func (q *Queries) GetUserByName(ctx context.Context, name string) (GetUserByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByName, name)
	var i GetUserByNameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.Session,
		&i.LoggedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByNameWithPassword = `-- name: GetUserByNameWithPassword :one
SELECT id, name, password, is_active, session, logged_at, created_at FROM users WHERE name = ? LIMIT 1
`

func (q *Queries) GetUserByNameWithPassword(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByNameWithPassword, name)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Password,
		&i.IsActive,
		&i.Session,
		&i.LoggedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserBySession = `-- name: GetUserBySession :one
SELECT id, name, is_active, session, logged_at, created_at 
  FROM users WHERE session = ? and session <> "" and session is not null  LIMIT 1
`

type GetUserBySessionRow struct {
	ID        int64      `db:"id" json:"id"`
	Name      string     `db:"name" json:"name" validate:"required"`
	IsActive  *bool      `db:"is_active" json:"is_active"`
	Session   *string    `db:"session" json:"session"`
	LoggedAt  *time.Time `db:"logged_at" json:"logged_at"`
	CreatedAt *time.Time `db:"created_at" json:"created_at"`
}

func (q *Queries) GetUserBySession(ctx context.Context, session *string) (GetUserBySessionRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBySession, session)
	var i GetUserBySessionRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.Session,
		&i.LoggedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many

select role from roles join user_roles on roles.id == user_roles.role_id 
 where user_roles.user_id == ?
`

// ---------------------------------------
// ---------------------------------------
func (q *Queries) GetUserRoles(ctx context.Context, userID int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var role string
		if err := rows.Scan(&role); err != nil {
			return nil, err
		}
		items = append(items, role)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithPassword = `-- name: GetUserWithPassword :one
SELECT id, name, password, is_active, session, logged_at, created_at FROM users WHERE id = ? LIMIT 1
`

func (q *Queries) GetUserWithPassword(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserWithPassword, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Password,
		&i.IsActive,
		&i.Session,
		&i.LoggedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listPokemons = `-- name: ListPokemons :many
SELECT id, name, image FROM pokemons ORDER BY id
`

func (q *Queries) ListPokemons(ctx context.Context) ([]Pokemon, error) {
	rows, err := q.db.QueryContext(ctx, listPokemons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pokemon
	for rows.Next() {
		var i Pokemon
		if err := rows.Scan(&i.ID, &i.Name, &i.Image); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPokemonsNames = `-- name: ListPokemonsNames :many
SELECT name FROM pokemons
`

func (q *Queries) ListPokemonsNames(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listPokemonsNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPokemonsOffset = `-- name: ListPokemonsOffset :many
SELECT id, name, image FROM pokemons ORDER BY id LIMIT ? OFFSET ?
`

type ListPokemonsOffsetParams struct {
	Limit  int64 `db:"limit" json:"limit"`
	Offset int64 `db:"offset" json:"offset"`
}

func (q *Queries) ListPokemonsOffset(ctx context.Context, arg ListPokemonsOffsetParams) ([]Pokemon, error) {
	rows, err := q.db.QueryContext(ctx, listPokemonsOffset, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pokemon
	for rows.Next() {
		var i Pokemon
		if err := rows.Scan(&i.ID, &i.Name, &i.Image); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, is_active, session, logged_at, created_at FROM users ORDER BY id
`

type ListUsersRow struct {
	ID        int64      `db:"id" json:"id"`
	Name      string     `db:"name" json:"name" validate:"required"`
	IsActive  *bool      `db:"is_active" json:"is_active"`
	Session   *string    `db:"session" json:"session"`
	LoggedAt  *time.Time `db:"logged_at" json:"logged_at"`
	CreatedAt *time.Time `db:"created_at" json:"created_at"`
}

func (q *Queries) ListUsers(ctx context.Context) ([]ListUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.IsActive,
			&i.Session,
			&i.LoggedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :one
UPDATE users set name = ?, password = ?, is_active = ? WHERE id = ?
RETURNING id, name, is_active, session, logged_at, created_at
`

type UpdateUserParams struct {
	Name     string `db:"name" json:"name" validate:"required"`
	Password string `db:"password" json:"password" validate:"required"`
	IsActive *bool  `db:"is_active" json:"is_active"`
	ID       int64  `db:"id" json:"id"`
}

type UpdateUserRow struct {
	ID        int64      `db:"id" json:"id"`
	Name      string     `db:"name" json:"name" validate:"required"`
	IsActive  *bool      `db:"is_active" json:"is_active"`
	Session   *string    `db:"session" json:"session"`
	LoggedAt  *time.Time `db:"logged_at" json:"logged_at"`
	CreatedAt *time.Time `db:"created_at" json:"created_at"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRowContext(ctx, updateUser,
		arg.Name,
		arg.Password,
		arg.IsActive,
		arg.ID,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.Session,
		&i.LoggedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateUserActiveState = `-- name: UpdateUserActiveState :one
UPDATE users set is_active = ? WHERE id = ?
RETURNING id, name, is_active, session, logged_at, created_at
`

type UpdateUserActiveStateParams struct {
	IsActive *bool `db:"is_active" json:"is_active"`
	ID       int64 `db:"id" json:"id"`
}

type UpdateUserActiveStateRow struct {
	ID        int64      `db:"id" json:"id"`
	Name      string     `db:"name" json:"name" validate:"required"`
	IsActive  *bool      `db:"is_active" json:"is_active"`
	Session   *string    `db:"session" json:"session"`
	LoggedAt  *time.Time `db:"logged_at" json:"logged_at"`
	CreatedAt *time.Time `db:"created_at" json:"created_at"`
}

func (q *Queries) UpdateUserActiveState(ctx context.Context, arg UpdateUserActiveStateParams) (UpdateUserActiveStateRow, error) {
	row := q.db.QueryRowContext(ctx, updateUserActiveState, arg.IsActive, arg.ID)
	var i UpdateUserActiveStateRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.IsActive,
		&i.Session,
		&i.LoggedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateUserSession = `-- name: UpdateUserSession :exec
UPDATE users set session = ?, logged_at = ? WHERE id = ?
`

type UpdateUserSessionParams struct {
	Session  *string    `db:"session" json:"session"`
	LoggedAt *time.Time `db:"logged_at" json:"logged_at"`
	ID       int64      `db:"id" json:"id"`
}

func (q *Queries) UpdateUserSession(ctx context.Context, arg UpdateUserSessionParams) error {
	_, err := q.db.ExecContext(ctx, updateUserSession, arg.Session, arg.LoggedAt, arg.ID)
	return err
}
